<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Tierlist by Game Links</title>
<style>
* { box-sizing: border-box; }

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #020617;
  color: #e5e7eb;
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  font-size: 20px; /* ~150% */
}

.container {
  margin: 52px 30px;
  max-width: 1400px;
  width: 100%;
  background: #020617;
  border-radius: 24px;
  padding: 34px;
  box-shadow: 0 32px 70px rgba(0, 0, 0, 0.95);
  border: 1px solid #1f2937;
  display: grid;
  grid-template-columns: minmax(0, 1.35fr) minmax(0, 1fr);
  gap: 40px;
}

@media (max-width: 900px) {
  .container {
    grid-template-columns: 1fr;
    margin: 24px 14px;
    padding: 22px;
  }
}

h1 {
  margin: 0;
  font-size: 2.1rem;
}

.subtitle {
  margin-top: 8px;
  margin-bottom: 22px;
  font-size: 1.02rem;
  color: #9ca3af;
  line-height: 1.7;
}

label {
  display: block;
  font-size: 1.02rem;
  margin-bottom: 10px;
}

input[type="text"] {
  width: 100%;
  padding: 15px 18px;
  border-radius: 14px;
  border: 1px solid #4b5563;
  background: #020617;
  color: #e5e7eb;
  font-size: 1.02rem;
}

input[type="text"]::placeholder { color: #6b7280; }

input[type="text"]:focus {
  outline: none;
  border-color: #38bdf8;
  box-shadow: 0 0 0 1px #38bdf8;
}

textarea {
  width: 100%;
  padding: 15px 18px;
  border-radius: 14px;
  border: 1px solid #4b5563;
  background: #020617;
  color: #e5e7eb;
  font-size: 1.02rem;
  resize: vertical;
  min-height: 120px;
}

textarea::placeholder { color: #6b7280; }

textarea:focus {
  outline: none;
  border-color: #38bdf8;
  box-shadow: 0 0 0 1px #38bdf8;
}

input[type="file"] {
  font-size: 0.9rem;
}

button {
  padding: 13px 24px;
  border-radius: 999px;
  border: none;
  background: linear-gradient(135deg, #a855f7, #22d3ee);
  color: #020617;
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.1s ease;
  box-shadow: 0 16px 36px rgba(168, 85, 247, 0.45);
}

button:hover {
  filter: brightness(1.07);
  transform: translateY(-2px);
  box-shadow: 0 22px 50px rgba(168, 85, 247, 0.6);
}

button:active {
  transform: translateY(0);
  box-shadow: 0 10px 26px rgba(168, 85, 247, 0.35);
}

button[disabled] {
  opacity: 0.55;
  cursor: default;
  transform: none;
  box-shadow: none;
  filter: none;
}

.btn-secondary {
  background: #111827;
  color: #e5e7eb;
  box-shadow: none;
  border: 1px solid #4b5563;
}

.btn-secondary:hover {
  filter: brightness(1.08);
  box-shadow: 0 12px 28px rgba(15, 23, 42, 0.85);
}

.btn-icon {
  min-width: 32px;
  height: 32px;
  padding: 0;
  border-radius: 999px;
  border: 1px solid #4b5563;
  background: #111827;
  color: #e5e7eb;
  font-size: 18px;
  line-height: 0;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  box-shadow: none;
}

.btn-icon + .btn-icon {
  margin-left: 6px;
}

.btn-icon:hover {
  background: #1f2937;
  border-color: #9ca3af;
  box-shadow: 0 0 0 0;
  transform: translateY(0);
}

.btn-icon.danger:hover {
  background: #b91c1c;
  border-color: #ef4444;
}

.btn-toggle {
  padding: 6px 14px;
  font-size: 0.86rem;
  box-shadow: none;
}

.status {
  margin-top: 14px;
  font-size: 0.98rem;
  padding: 12px 14px;
  border-radius: 12px;
}

.status.info {
  background: rgba(59, 130, 246, 0.12);
  border: 1px solid rgba(59, 130, 246, 0.6);
  color: #bfdbfe;
}

.status.error {
  background: rgba(239, 68, 68, 0.12);
  border: 1px solid rgba(239, 68, 68, 0.7);
  color: #fecaca;
}

.status.success {
  background: rgba(34, 197, 94, 0.12);
  border: 1px solid #22c55e;
  color: #bbf7d0;
}

.section-title {
  font-size: 1.12rem;
  font-weight: 600;
  margin-bottom: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.small-hint {
  font-size: 0.9rem;
  color: #6b7280;
}

.list {
  margin-top: 12px;
  max-height: 520px;
  overflow-y: auto;
  padding-right: 8px;
}

.game-item {
  display: flex;
  align-items: center;
  gap: 14px;
  padding: 12px 14px;
  border-radius: 14px;
  border: 1px solid #111827;
  background: #020617;
  margin-bottom: 10px;
}

.game-thumb {
  width: 110px;
  height: 62px;
  border-radius: 10px;
  object-fit: cover;
  background: #020617;
  border: 1px solid #1f2937;
}

.game-info { flex: 1; min-width: 0; }

.game-title {
  font-size: 1.02rem;
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.game-url {
  font-size: 0.86rem;
  color: #6b7280;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tier-controls {
  margin-top: 14px;
  display: flex;
  gap: 14px;
  flex-wrap: wrap;
  align-items: center;
}

.finished-list {
  margin-top: 16px;
  border-radius: 16px;
  border: 1px solid #111827;
  padding: 12px;
  background: #020617;
  max-height: 260px;
  overflow-y: auto;
}

.rank-row {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 9px 11px;
  border-radius: 12px;
}

.rank-number {
  width: 34px;
  text-align: right;
  font-size: 0.96rem;
  color: #9ca3af;
}

.rank-title {
  font-size: 1.03rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.rank-badge {
  font-size: 0.86rem;
  padding: 4px 10px;
  border-radius: 999px;
  border: 1px solid #4b5563;
  color: #9ca3af;
  margin-left: auto;
}

.tier-table { margin-top: 20px; }

.tier-table-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.tier-table-wrapper {
  border-radius: 20px;
  border: 1px solid #111827;
  overflow: hidden;
  background: #020617;
}

.tier-row {
  display: flex;
  min-height: 96px;
  border-bottom: 1px solid #111827;
}

.tier-row:last-child { border-bottom: none; }

.tier-label-cell {
  width: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 800;
  font-size: 1.3rem;
  color: #020617;
}

.tier-items-cell {
  flex: 1;
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 12px;
  padding: 10px 12px;
}

.tier-item-img {
  width: 140px;
  height: 80px;
  border-radius: 10px;
  object-fit: cover;
  background: #020617;
  border: 1px solid #1f2937;
}

/* Allgemeines Overlay (Auto + Manuell) */

.overlay {
  position: fixed;
  inset: 0;
  background: #020617;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding: 40px 24px;
  z-index: 50;
}

.overlay-inner {
  max-width: 1100px;
  width: 100%;
  background: #020617;
  border-radius: 22px;
  padding: 26px;
  border: 1px solid #1f2937;
  box-shadow: 0 28px 60px rgba(0, 0, 0, 0.9);
}

.overlay-title {
  margin: 0 0 8px;
  font-size: 2rem;
}

.overlay-subtitle {
  margin: 0 0 18px;
  font-size: 0.98rem;
  color: #9ca3af;
}

.overlay-status {
  font-size: 0.96rem;
  color: #9ca3af;
  margin-bottom: 12px;
}

.compare-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
}

@media (max-width: 900px) {
  .compare-grid { grid-template-columns: 1fr; }
}

.compare-card {
  border-radius: 16px;
  border: 1px solid #1f2937;
  background: #020617;
  padding: 14px;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  gap: 11px;
  transition: transform 0.08s ease, box-shadow 0.08s ease,
              border-color 0.08s ease, background 0.08s ease;
}

.compare-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 18px 50px rgba(0, 0, 0, 0.9);
  border-color: #38bdf8;
  background: #020a23;
}

.compare-card img {
  width: 100%;
  height: 260px;
  border-radius: 12px;
  object-fit: cover;
  background: #020617;
  border: 1px solid #111827;
}

.compare-label {
  font-size: 0.86rem;
  color: #9ca3af;
}

.compare-name {
  font-size: 1.02rem;
  font-weight: 500;
}

.overlay-footer {
  margin-top: 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.9rem;
  color: #6b7280;
}

.lang-select-wrapper {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.9rem;
  color: #9ca3af;
}

#langSelect {
  background: #020617;
  color: #e5e7eb;
  border-radius: 999px;
  border: 1px solid #4b5563;
  padding: 6px 10px;
  font-size: 0.9rem;
}

.mode-select-wrapper {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.9rem;
  color: #9ca3af;
}

#modeSelect {
  background: #020617;
  color: #e5e7eb;
  border-radius: 999px;
  border: 1px solid #4b5563;
  padding: 6px 10px;
  font-size: 0.9rem;
}

/* --- Manueller Tierlist Overlay --- */

.manual-overlay {
  position: fixed;
  inset: 0;
  background: #020617;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding: 40px 24px;
  z-index: 55;
}

.manual-inner {
  max-width: 1300px;
  width: 100%;
  background: #020617;
  border-radius: 22px;
  padding: 26px;
  border: 1px solid #1f2937;
  box-shadow: 0 28px 60px rgba(0, 0, 0, 0.9);
}

.manual-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
}

.manual-grid {
  display: grid;
  grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.1fr);
  gap: 20px;
}

@media (max-width: 1100px) {
  .manual-grid {
    grid-template-columns: 1fr;
  }
}

.manual-pool {
  border-radius: 16px;
  border: 1px solid #111827;
  padding: 12px;
  background: #020617;
  max-height: 520px;
  overflow-y: auto;
}

.manual-pool-title {
  font-size: 0.92rem;
  color: #9ca3af;
  margin-bottom: 8px;
}

.manual-pool-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

/* Karten im manuellen Tierlist: Bild oben, Titel unten, größer */
.manual-card,
.manual-tier-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  gap: 6px;
  padding: 8px 10px;
  border-radius: 12px;
  border: 1px solid #111827;
  background: #020617;
  cursor: grab;
  user-select: none;
  max-width: 190px;
}

.manual-card:active,
.manual-tier-card:active {
  cursor: grabbing;
}

/* Bildgröße – deutlich größer, breiter als hoch */
.manual-card-img,
.manual-tier-card-img,
.manual-card-thumb,
.manual-tier-card-thumb {
  width: 170px;
  height: 100px;
  border-radius: 10px;
  object-fit: cover;
  border: 1px solid #111827;
  background: #020617;
}

/* Titel unter dem Bild, gekürzt */
.manual-card-name,
.manual-tier-card-name,
.manual-card-title,
.manual-tier-card-title {
  font-size: 0.86rem;
  text-align: center;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 180px;
}

/* Manuelle Tier-Tabelle */

.manual-tier-wrapper {
  border-radius: 20px;
  border: 1px solid #111827;
  background: #020617;
  overflow: hidden;
  padding: 0;
}

.manual-tier-row {
  display: flex;
  min-height: 96px;
  border-bottom: 1px solid #111827;
}

.manual-tier-row:last-child {
  border-bottom: none;
}

.manual-tier-label {
  width: 120px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 800;
  font-size: 1.1rem;
  color: #020617;
  padding: 4px 6px;
  text-align: center;
  outline: none; /* für contentEditable */
}

.manual-tier-dropzone {
  flex: 1;
  padding: 10px 12px;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
  min-height: 96px;
}

.manual-tier-dropzone.over,
#manualPoolList.over {
  outline: 2px dashed #38bdf8;
  outline-offset: 2px;
}

/* Edit-Dialog */

.edit-overlay {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.9);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 60;
}

.edit-inner {
  width: 100%;
  max-width: 480px;
  background: #020617;
  border-radius: 18px;
  border: 1px solid #1f2937;
  padding: 20px 22px;
  box-shadow: 0 24px 60px rgba(0, 0, 0, 0.9);
}

.edit-inner h2 {
  margin-top: 0;
  margin-bottom: 12px;
  font-size: 1.4rem;
}

.edit-preview {
  width: 100%;
  max-height: 180px;
  border-radius: 12px;
  object-fit: cover;
  background: #020617;
  border: 1px solid #111827;
  margin-bottom: 12px;
}

.edit-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 16px;
}

/* Manueller Eintrag (aufklappbar) */

details.manual-details {
  margin-top: 24px;
  border-radius: 14px;
  border: 1px solid #1f2937;
  background: #020617;
  padding: 10px 14px 14px;
}

details.manual-details > summary {
  cursor: pointer;
  list-style: none;
  font-size: 1.02rem;
}

details.manual-details > summary::-webkit-details-marker {
  display: none;
}

.manual-details summary::before {
  content: "▶ ";
  font-size: 0.9rem;
  color: #9ca3af;
}

.manual-details[open] summary::before {
  content: "▼ ";
}

.manual-details-content {
  margin-top: 10px;
}

.hidden {
  display: none !important;
}
/* 1) Manuelle Tierlist Overlay scrollbar machen – bis ganz nach unten */
.manual-overlay {
  /* alles Alte bleibt, wir überschreiben nur die Höhe */
  overflow-y: auto;
  max-height: none;   /* alte Begrenzung weg */
  height: 100vh;      /* immer volle Fensterhöhe */
}

/* 2) Rechte Tierlist-Tabelle etwas breiter machen */
.manual-grid {
  /* linke Spalte schmaler, rechte breiter */
  grid-template-columns: minmax(0, 0.75fr) minmax(0, 1.5fr);
}

/* Karten etwas kompakter, damit mehr pro Zeile passen */
.manual-card,
.manual-tier-card {
  max-width: 190px;        /* vorher 190px */
}

.manual-card-img,
.manual-tier-card-img,
.manual-card-thumb,
.manual-tier-card-thumb {
  width: 170px;            /* vorher 170px */
  height: 110px;            /* leicht kleiner, damit es nicht zu hoch wird */
}

/* 3) Rang-Namen mit Innenabstand + Ellipsis */
/* Rang-Label: kein Ellipsis mehr, Text normal */
.manual-tier-label {
  padding: 6px;          /* etwas Abstand innen */
  white-space: normal;   /* darf umbrechen */
  overflow: visible;
  text-overflow: clip;   /* kein … */
  box-sizing: border-box;
}

/* Eingabefeld für Rang-Namen (Schreibbox) – links/rechts Abstand */
.manual-tier-label input {
  width: 100%;
  padding: 4px 10px;     /* links/rechts Abstand in der Box */
  box-sizing: border-box;
  border-radius: 8px;    /* optional, sieht schöner aus */
  border: 1px solid #1f2937;
  background: rgba(15,23,42,0.9);
  color: #e5e7eb;
}
  /* Manueller Tierlist-Button soll aussehen wie der Auto-Button */
#startManualTierButton {
  background: linear-gradient(135deg, #a855f7, #22d3ee);
  color: #020617;
  font-weight: 600;
  border: none;
  box-shadow: 0 16px 36px rgba(168, 85, 247, 0.45);
}

/* Hover-Style wie beim normalen Button */
#startManualTierButton:hover {
  filter: brightness(1.07);
  transform: translateY(-2px);
  box-shadow: 0 22px 50px rgba(168, 85, 247, 0.6);
}

/* Active-Style */
#startManualTierButton:active {
  transform: translateY(0);
  box-shadow: 0 10px 26px rgba(168, 85, 247, 0.35);
}

/* Disabled-Zustand wie beim Auto-Button */
#startManualTierButton[disabled] {
  opacity: 0.55;
  cursor: default;
  transform: none;
  box-shadow: none;
  filter: none;
}

</style>
</head>
<body>
<div class="container" id="mainContainer">
  <!-- Linke Seite -->
  <div>
    <div style="display:flex; justify-content:space-between; align-items:center; gap:16px; margin-bottom:6px;">
      <h1 id="txt_title">Тир-лист по ссылкам на игры</h1>
      <div class="lang-select-wrapper">
        <span id="lbl_lang">Язык</span>
        <select id="langSelect">
          <option value="ru">Русский</option>
          <option value="en">English</option>
          <option value="de">Deutsch</option>
        </select>
      </div>
    </div>
    <p class="subtitle" id="txt_subtitle">
      1. Вводи URL страниц игр (Steam, itch.io, Epic, GOG и т.д.).<br>
      2. Загружай метаданные и добавляй игры в список.<br>
      3. Нажми «Начать тир-лист» – появится полноэкранный режим с двумя играми.
    </p>

    <label for="urlInput" id="lbl_url">URL игры</label>
    <input id="urlInput"
           type="text"
           placeholder="Например: https://store.steampowered.com/app/570/Dota_2/">
    <div style="margin-top: 12px; display:flex; gap:14px; flex-wrap:wrap;">
      <button id="addButton" type="button">Загрузить и добавить игру</button>
      <button id="clearButton" type="button" class="btn-secondary">Очистить список</button>
    </div>

    <label for="multiInput" id="lbl_multi" style="margin-top: 22px;">Несколько URL (по одному в строке)</label>
    <textarea id="multiInput"
              placeholder="Каждый URL на новой строке&#10;Например:&#10;https://store.steampowered.com/app/570/Dota_2/&#10;https://store.steampowered.com/app/730/CounterStrike_2/"></textarea>
    <div style="margin-top: 10px; display:flex; gap:12px; flex-wrap:wrap; align-items:center;">
      <button id="addManyButton" type="button" class="btn-secondary">
        Загрузить все ссылки
      </button>
      <span class="small-hint" id="hint_multi">
        Пустые строки будут пропущены.
      </span>
    </div>

    <!-- Manueller Eintrag (einklappbar) -->
    <div style="margin-top: 26px; padding-top: 16px; border-top: 1px solid #1f2937;">
      <div class="section-title" style="margin-bottom: 4px;">
        <span id="lbl_manual_section">Своя игра (ручной ввод)</span>
        <button id="toggleManualSection" type="button" class="btn-secondary btn-toggle">▼</button>
      </div>
      <div id="manualSectionBody" class="hidden">
        <label for="manualTitle" id="lbl_manual_name">Название игры</label>
        <input id="manualTitle" type="text">

        <label for="manualImageUrl" id="lbl_manual_image_url" style="margin-top: 12px;">
          Картинка: URL (опционально)
        </label>
        <input id="manualImageUrl" type="text" placeholder="https://…">

        <label for="manualImage" id="lbl_manual_image_file" style="margin-top: 12px;">
          Картинка: файл (опционально)
        </label>
        <input id="manualImage" type="file" accept="image/*">

        <div style="margin-top: 10px; display:flex; gap:12px; flex-wrap:wrap; align-items:center;">
          <button id="addManualButton" type="button" class="btn-secondary">
            Добавить свою игру
          </button>
        </div>
        <div class="small-hint" id="manual_hint">
          Если указан и URL, и файл, приоритет у файла.
        </div>
      </div>
    </div>

    <div id="status" class="status hidden"></div>

    <div style="margin-top: 28px;">
      <div class="section-title">
        <span id="title_collected">Собранные игры</span>
        <span class="small-hint" id="gameCountHint">0 игр</span>
      </div>
      <div class="list" id="gameList"></div>
      <div class="tier-controls">
        <button id="startTierButton" type="button" disabled>
          Начать авто-тир-лист
        </button>
        <button id="startManualTierButton" type="button" class="btn-secondary" disabled>
          Ручной тир-лист
        </button>
        <span class="small-hint" id="hint_min_games">
          Нужно минимум 5 игр.
        </span>
        <div class="mode-select-wrapper">
          <span id="modeLabel">Режим ранжирования</span>
          <select id="modeSelect">
            <option value="exact">Точный (больше кликов)</option>
            <option value="fast">Быстрый (приблизительный)</option>
          </select>
        </div>
      </div>
      <div class="small-hint" id="clickStats" style="margin-top:4px;"></div>
    </div>

    <!-- Share nur Spiele (ohne Ranking) -->
    <div style="margin-top: 26px; padding-top: 16px; border-top: 1px solid #1f2937;">
      <div class="section-title">
        <span id="share_title">Spiele teilen (ohne Ranking)</span>
      </div>
      <span class="small-hint" id="share_hint">
        Erzeuge einen Code oder nutze einen GitHub Gist. Beim Import werden nur die Spiele übernommen,
        das Ranking muss die andere Person selbst neu machen.
      </span>
      <div style="margin-top: 10px; display:flex; gap:12px; flex-wrap:wrap;">
        <button id="btnExportGames" type="button" class="btn-secondary">
          Spiele-Exportcode erzeugen
        </button>
        <button id="btnImportGames" type="button" class="btn-secondary">
          Spiele-Exportcode / Gist einfügen
        </button>
      </div>
    </div>
  </div>

  <!-- Rechte Seite -->
  <div>
    <div class="section-title">
      <span id="title_result">Результат тир-листа</span>
      <span class="small-hint" id="progressInfo">Ещё не запущено</span>
    </div>

    <div id="finishedPanel" class="finished-list hidden">
      <div class="small-hint" style="margin-bottom:8px;" id="hint_sorted_list">
        Отсортированный список (1 = любимая игра):
      </div>
      <div id="rankList"></div>
    </div>

    <div id="tierTableSection" class="tier-table hidden">
      <div class="tier-table-header">
        <span class="small-hint" id="hint_visual">
          Визуальный тир-лист (S / A / B / C / D).
        </span>
        <button id="downloadTierImageButton" type="button" class="btn-secondary">
          Скачать таблицу как картинку
        </button>
      </div>
      <div id="tierTableWrapper" class="tier-table-wrapper"></div>
    </div>
  </div>
</div>

<!-- Vollbild-Vergleich (Auto-Tierlist) -->
<div id="compareOverlay" class="overlay hidden">
  <div class="overlay-inner">
    <h1 class="overlay-title" id="txt_overlay_title">Сравнение игр</h1>
    <p class="overlay-subtitle" id="txt_overlay_subtitle">
      Нажимай на игру, которую ты любишь больше. После окончания результат появится в основном окне.
    </p>
    <div id="fsStatus" class="overlay-status"></div>
    <div class="compare-grid">
      <div class="compare-card" id="fsCardLeft">
        <div class="compare-label" id="lbl_left_choice">Левый выбор</div>
        <img id="fsImgLeft" src="" alt="">
        <div class="compare-name" id="fsNameLeft">—</div>
      </div>
      <div class="compare-card" id="fsCardRight">
        <div class="compare-label" id="lbl_right_choice">Правый выбор</div>
        <img id="fsImgRight" src="" alt="">
        <div class="compare-name" id="fsNameRight">—</div>
      </div>
    </div>
    <div class="overlay-footer">
      <span id="fsProgress">0 сравнений</span>
      <button id="fsCancel" type="button" class="btn-secondary">Отменить</button>
    </div>
  </div>
</div>

<!-- Manueller Tierlist -->
<div id="manualOverlay" class="manual-overlay hidden">
  <div class="manual-inner">
    <div class="manual-header">
      <h1 class="overlay-title" id="manual_title">Ручной тир-лист</h1>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button id="manualBackButton" type="button" class="btn-secondary">
          Zurück
        </button>
        <button id="downloadManualTierImageButton" type="button" class="btn-secondary">
          Manuelle Tierlist als Bild
        </button>
      </div>
    </div>
    <p class="overlay-subtitle" id="manual_subtitle">
      Перетаскивай игры из списка слева в нужный тир справа. Этот тир-лист независим от автоматического.
    </p>

    <div class="manual-grid">
      <div>
        <div class="section-title">
          <span id="manual_pool_title">Все игры (перетащи в тиры справа):</span>
        </div>
        <div class="manual-pool">
          <div class="manual-pool-title" id="manual_pool_subtitle">
            Все игры (перетащи в тиры справа):
          </div>
          <div id="manualPoolList" class="manual-pool-list"></div>
        </div>
      </div>
      <div>
        <div class="manual-header">
          <span class="small-hint" id="manual_tiers_hint">
            Визуальный ручной тир-лист (S / A / B / C / D).
          </span>
        </div>
        <div id="manualTierWrapper" class="manual-tier-wrapper">
          <!-- Reihen S/A/B/C/D werden per JS erzeugt -->
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Edit-Dialog zum Bearbeiten eines Spiels -->
<div id="editOverlay" class="edit-overlay hidden">
  <div class="edit-inner">
    <h2 id="editDialogTitle">Spiel bearbeiten</h2>

    <img id="editPreview" class="edit-preview" src="" alt="">

    <label for="editGameName" id="editLabelName">Name</label>
    <input id="editGameName" type="text">

    <label for="editImageUrl" id="editLabelImageUrl" style="margin-top:12px;">
      Bild-URL (optional)
    </label>
    <input id="editImageUrl" type="text" placeholder="https://…">

    <label for="editImageFile" id="editLabelImageFile" style="margin-top:12px;">
      Bild-Datei (optional)
    </label>
    <input id="editImageFile" type="file" accept="image/*">

    <div class="edit-actions">
      <button id="editCancelButton" type="button" class="btn-secondary">
        Abbrechen
      </button>
      <button id="editSaveButton" type="button">
        Speichern
      </button>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<script>
/* ---------- I18N ---------- */
const I18N = {
  ru: {
    page_title: "Тир-лист по ссылкам на игры",
    main_title: "Тир-лист по ссылкам на игры",
    lang_label: "Язык",
    subtitle_html:
      "1. Вводи URL страниц игр (Steam, itch.io, Epic, GOG и т.д.).<br>" +
      "2. Загружай метаданные и добавляй игры в список.<br>" +
      "3. Нажми «Начать тир-лист» – появится полноэкранный режим с двумя играми.",
    label_url: "URL игры",
    placeholder_url: "Например: https://store.steampowered.com/app/570/Dota_2/",
    label_multi: "Несколько URL (по одному в строке)",
    placeholder_multi:
      "Каждый URL на новой строке\nНапример:\nhttps://store.steampowered.com/app/570/Dota_2/\nhttps://store.steampowered.com/app/730/CounterStrike_2/",
    btn_add_game: "Загрузить и добавить игру",
    btn_clear_list: "Очистить список",
    btn_add_many: "Загрузить все ссылки",
    hint_multi: "Пустые строки будут пропущены.",
    section_collected: "Собранные игры",
    hint_min_games: "Нужно минимум 5 игр.",
    result_title: "Результат тир-листа",
    finished_hint: "Отсортированный список (1 = любимая игра):",
    tier_visual_hint: "Визуальный тир-лист (S / A / B / C / D).",
    btn_download_image: "Скачать таблицу как картинку",
    overlay_title: "Сравнение игр",
    overlay_subtitle:
      "Нажимай на игру, которую ты любишь больше. После окончания результат появится в основном окне.",
    overlay_left_label: "Левый выбор",
    overlay_right_label: "Правый выбор",
    overlay_cancel: "Отменить",
    manual_section_title: "Своя игра (ручной ввод)",
    manual_label_name: "Название игры",
    manual_label_image_file: "Картинка: файл (опционально)",
    manual_label_image_url: "Картинка: URL (опционально)",
    manual_hint: "Если указан и URL, и файл, приоритет у файла.",
    btn_add_manual: "Добавить свою игру",
    mode_label: "Режим ранжирования",
    mode_exact: "Точный (больше кликов)",
    mode_fast: "Быстрый (приблизительный)",
    click_stats: "Теоретический минимум: {min} кликов. Полный режим ≈ {exact}, быстрый режим ≈ {fast}.",
    btn_start_auto: "Авто-тир-лист",
    btn_start_manual: "Ручной тир-лист",
    progress_finished: "Готово! Всего {count}.",
    progress_running: "Идёт сравнение… ({count})",
    progress_need_n: "Нужно минимум 5 игр.",
    progress_not_started: "Ещё не запущено",
    progress_stopped: "Сравнение остановлено.",
    progress_cancelled: "Сравнение отменено.",
    overlay_status_start: "Начинаем сравнение…",
    status_update_game: "Обновляю игру: {title}",
    status_update_game_ok: "Игра обновлена: {title}",
    status_update_game_fail: "Не удалось обновить игру: {error}",
    status_enter_url: "Пожалуйста, введите URL.",
    status_loading_meta: "Загружаю метаданные…",
    status_game_added: "Игра добавлена: {title}",
    status_load_error: "Ошибка загрузки: {error}",
    status_manual_need_title: "Введите название игры.",
    status_manual_need_image: "Выберите картинку или укажите URL картинки.",
    status_manual_loading: "Читаю файл картинки…",
    status_manual_added: "Своя игра добавлена: {title}",
    status_manual_file_error: "Не удалось прочитать файл картинки.",
    status_manual_need_image_or_url: "Укажите хотя бы URL или выберите файл картинки (или оставьте старую).",
    status_no_links: "Нет ссылок для добавления. Введите хотя бы одну строку.",
    status_loading_multi_progress: "Загружаю {current} из {total}…",
    status_multi_success: "Успешно добавлено игр: {count}",
    status_multi_partial: "Добавлено {success} игр, ошибок: {fail}.",
    status_multi_fail: "Не удалось добавить ссылки.",
    tierlist_not_created: "Сначала создай тир-лист.",
    tierlist_save_error: "Не удалось сохранить картинку тир-листа.",
    // Share / Import
    share_title: "Шеринг списка игр (без ранкинга)",
    share_hint: "Создай код или используй GitHub Gist. При импорте загружаются только игры.",
    btn_export_games: "Создать код списка игр",
    btn_import_games: "Вставить код / Gist списка игр",
    share_no_games: "Нет игр для экспорта.",
    share_export_copied: "Код успешно скопирован в буфер обмена.",
    share_export_copy_manual: "Скопируйте код вручную из окна.",
    share_import_prompt: "Вставьте сюда код списка игр или URL Gist:",
    share_import_success: "Игры успешно импортированы. Рейтинг был сброшен.",
    share_import_fail: "Импорт не удался: {error}",
    // Manueller Tierlist
    manual_title: "Ручной тир-лист",
    manual_subtitle: "Перетаскивай игры из списка слева в нужный тир справа. Этот тир-лист независим от автоматического.",
    manual_pool_title: "Все игры (перетащи в тиры справа):",
    manual_tiers_hint: "Визуальный ручной тир-лист (S / A / B / C / D).",
    manual_back: "Назад",
    manual_download_btn: "Скачать ручной тир-лист",
    manual_save_error: "Не удалось сохранить ручной тир-лист.",
    // Edit
    edit_title: "Редактировать игру",
    edit_label_name: "Название",
    edit_label_image_url: "URL картинки (опционально)",
    edit_label_image_file: "Файл картинки (опционально)",
    edit_cancel: "Отмена",
    edit_save: "Сохранить",
    status_edit_saved: "Игра обновлена."
  },
  en: {
    page_title: "Tierlist by Game Links",
    main_title: "Tierlist by Game Links",
    lang_label: "Language",
    subtitle_html:
      "1. Paste URLs of game pages (Steam, itch.io, Epic, GOG, etc.).<br>" +
      "2. Load metadata and add the games to the list.<br>" +
      "3. Click “Start tierlist” – a full screen with two games will appear.",
    label_url: "Game URL",
    placeholder_url: "Example: https://store.steampowered.com/app/570/Dota_2/",
    label_multi: "Multiple URLs (one per line)",
    placeholder_multi:
      "One URL per line\nExample:\nhttps://store.steampowered.com/app/570/Dota_2/\nhttps://store.steampowered.com/app/730/CounterStrike_2/",
    btn_add_game: "Load and add game",
    btn_clear_list: "Clear list",
    btn_add_many: "Load all links",
    hint_multi: "Empty lines will be skipped.",
    section_collected: "Collected games",
    hint_min_games: "At least 5 games are required.",
    result_title: "Tierlist result",
    finished_hint: "Sorted list (1 = favorite game):",
    tier_visual_hint: "Visual tierlist (S / A / B / C / D).",
    btn_download_image: "Download table as image",
    overlay_title: "Game comparison",
    overlay_subtitle:
      "Click on the game you like more. When it’s done, the result appears in the main window.",
    overlay_left_label: "Left choice",
    overlay_right_label: "Right choice",
    overlay_cancel: "Cancel",
    manual_section_title: "Custom game (manual input)",
    manual_label_name: "Game title",
    manual_label_image_file: "Image file (optional)",
    manual_label_image_url: "Image URL (optional)",
    manual_hint: "If both URL and file are set, the file has priority.",
    btn_add_manual: "Add custom game",
    mode_label: "Ranking mode",
    mode_exact: "Exact (more clicks)",
    mode_fast: "Fast (approximate)",
    click_stats: "Theoretical minimum: {min} clicks. Exact mode ≈ {exact}, fast mode ≈ {fast}.",
    btn_start_auto: "Auto tierlist",
    btn_start_manual: "Manual tierlist",
    progress_finished: "Done! Total {count}.",
    progress_running: "Comparison running… ({count})",
    progress_need_n: "At least 5 games are required.",
    progress_not_started: "Not started yet",
    progress_stopped: "Comparison stopped.",
    progress_cancelled: "Comparison cancelled.",
    overlay_status_start: "Starting comparison…",
    status_update_game: "Updating game: {title}",
    status_update_game_ok: "Game updated: {title}",
    status_update_game_fail: "Could not update game: {error}",
    status_enter_url: "Please enter a URL.",
    status_loading_meta: "Loading metadata…",
    status_game_added: "Game added: {title}",
    status_load_error: "Load error: {error}",
    status_manual_need_title: "Please enter a game title.",
    status_manual_need_image: "Please choose a cover image or enter an image URL.",
    status_manual_loading: "Reading image file…",
    status_manual_added: "Custom game added: {title}",
    status_manual_file_error: "Could not read image file.",
    status_manual_need_image_or_url: "Set at least an image URL or choose a file (or leave the old one).",
    status_no_links: "No links to add. Enter at least one line.",
    status_loading_multi_progress: "Loading {current} of {total}…",
    status_multi_success: "Successfully added games: {count}",
    status_multi_partial: "Added {success} games, errors: {fail}.",
    status_multi_fail: "Could not add links.",
    tierlist_not_created: "Create the tierlist first.",
    tierlist_save_error: "Could not save the tierlist image.",
    // Share / Import
    share_title: "Share games (without ranking)",
    share_hint: "Generate a code or use a GitHub Gist. On import only the games are loaded, the other person creates their own ranking.",
    btn_export_games: "Create games export code",
    btn_import_games: "Paste games export code / Gist",
    share_no_games: "There are no games to export.",
    share_export_copied: "Export code copied to clipboard.",
    share_export_copy_manual: "Copy the export code manually from the window.",
    share_import_prompt: "Paste the games export code or a Gist URL here:",
    share_import_success: "Games imported successfully. Ranking has been reset.",
    share_import_fail: "Import failed: {error}",
    // Manual tierlist
    manual_title: "Manual tierlist",
    manual_subtitle: "Drag games from the list on the left into the tiers on the right. This tierlist is independent from the automatic one.",
    manual_pool_title: "All games (drag into tiers on the right):",
    manual_tiers_hint: "Visual manual tierlist (S / A / B / C / D).",
    manual_back: "Back",
    manual_download_btn: "Download manual tierlist",
    manual_save_error: "Could not save manual tierlist image.",
    // Edit
    edit_title: "Edit game",
    edit_label_name: "Name",
    edit_label_image_url: "Image URL (optional)",
    edit_label_image_file: "Image file (optional)",
    edit_cancel: "Cancel",
    edit_save: "Save",
    status_edit_saved: "Game updated."
  },
  de: {
    page_title: "Tierlist aus Spiele-Links",
    main_title: "Tierlist aus Spiele-Links",
    lang_label: "Sprache",
    subtitle_html:
      "1. Füge URLs von Spieleseiten ein (Steam, itch.io, Epic, GOG usw.).<br>" +
      "2. Lade Metadaten und füge die Spiele zur Liste hinzu.<br>" +
      "3. Klicke auf „Tierlist starten“ – es erscheint ein Vollbild mit zwei Spielen.",
    label_url: "Spiel-URL",
    placeholder_url: "Beispiel: https://store.steampowered.com/app/570/Dota_2/",
    label_multi: "Mehrere URLs (eine pro Zeile)",
    placeholder_multi:
      "Eine URL pro Zeile\nBeispiel:\nhttps://store.steampowered.com/app/570/Dota_2/\nhttps://store.steampowered.com/app/730/CounterStrike_2/",
    btn_add_game: "Spiel laden und hinzufügen",
    btn_clear_list: "Liste löschen",
    btn_add_many: "Alle Links laden",
    hint_multi: "Leere Zeilen werden übersprungen.",
    section_collected: "Gesammelte Spiele",
    hint_min_games: "Mindestens 5 Spiele werden benötigt.",
    result_title: "Tierlist-Ergebnis",
    finished_hint: "Sortierte Liste (1 = Lieblingsspiel):",
    tier_visual_hint: "Visuelle Tierlist (S / A / B / C / D).",
    btn_download_image: "Tabelle als Bild herunterladen",
    overlay_title: "Spielvergleich",
    overlay_subtitle:
      "Klicke auf das Spiel, das du lieber magst. Danach erscheint das Ergebnis im Hauptfenster.",
    overlay_left_label: "Linke Auswahl",
    overlay_right_label: "Rechte Auswahl",
    overlay_cancel: "Abbrechen",
    manual_section_title: "Eigenes Spiel (manuell)",
    manual_label_name: "Spielname",
    manual_label_image_file: "Bild-Datei (optional)",
    manual_label_image_url: "Bild-URL (optional)",
    manual_hint: "Wenn URL und Datei angegeben sind, hat die Datei Priorität.",
    btn_add_manual: "Eigenes Spiel hinzufügen",
    mode_label: "Ranking-Modus",
    mode_exact: "Genau (mehr Klicks)",
    mode_fast: "Schnell (ungefähr)",
    click_stats: "Theoretisches Minimum: {min} Klicks. Exakter Modus ≈ {exact}, schneller Modus ≈ {fast}.",
    btn_start_auto: "Auto-Tierlist",
    btn_start_manual: "Manuelle Tierlist",
    progress_finished: "Fertig! Insgesamt {count}.",
    progress_running: "Vergleich läuft… ({count})",
    progress_need_n: "Mindestens 5 Spiele werden benötigt.",
    progress_not_started: "Noch nicht gestartet",
    progress_stopped: "Vergleich gestoppt.",
    progress_cancelled: "Vergleich abgebrochen.",
    overlay_status_start: "Starte Vergleich…",
    status_update_game: "Aktualisiere Spiel: {title}",
    status_update_game_ok: "Spiel aktualisiert: {title}",
    status_update_game_fail: "Spiel konnte nicht aktualisiert werden: {error}",
    status_enter_url: "Bitte eine URL eingeben.",
    status_loading_meta: "Lade Metadaten…",
    status_game_added: "Spiel hinzugefügt: {title}",
    status_load_error: "Fehler beim Laden: {error}",
    status_manual_need_title: "Bitte einen Spielnamen eingeben.",
    status_manual_need_image: "Bitte ein Cover-Bild auswählen oder eine Bild-URL eingeben.",
    status_manual_loading: "Lese Bilddatei…",
    status_manual_added: "Eigenes Spiel hinzugefügt: {title}",
    status_manual_file_error: "Bilddatei konnte nicht gelesen werden.",
    status_manual_need_image_or_url: "Gib mindestens eine Bild-URL an oder wähle eine Datei (oder lass das alte Bild).",
    status_no_links: "Keine Links zum Hinzufügen. Bitte mindestens eine Zeile eingeben.",
    status_loading_multi_progress: "Lade {current} von {total}…",
    status_multi_success: "{count} Spiele erfolgreich hinzugefügt.",
    status_multi_partial: "{success} Spiele hinzugefügt, Fehler: {fail}.",
    status_multi_fail: "Links konnten nicht hinzugefügt werden.",
    tierlist_not_created: "Erstelle zuerst eine Tierlist.",
    tierlist_save_error: "Tierlist-Bild konnte nicht gespeichert werden.",
    // Share / Import
    share_title: "Spiele teilen (ohne Ranking)",
    share_hint: "Erzeuge einen Code oder nutze einen GitHub Gist. Beim Import werden nur die Spiele übernommen, das Ranking muss die andere Person selbst neu machen.",
    btn_export_games: "Spiele-Exportcode erzeugen",
    btn_import_games: "Spiele-Exportcode / Gist einfügen",
    share_no_games: "Es gibt keine Spiele zum Exportieren.",
    share_export_copied: "Exportcode in die Zwischenablage kopiert.",
    share_export_copy_manual: "Kopiere den Exportcode manuell aus dem Fenster.",
    share_import_prompt: "Füge hier den Spiele-Exportcode oder eine Gist-URL ein:",
    share_import_success: "Spiele erfolgreich importiert. Ranking wurde zurückgesetzt.",
    share_import_fail: "Import fehlgeschlagen: {error}",
    // Manueller Tierlist
    manual_title: "Manuelle Tierlist",
    manual_subtitle: "Zieh Spiele aus der Liste links in die Tiers rechts. Diese Tierlist ist unabhängig von der automatischen.",
    manual_pool_title: "Alle Spiele (ziehe in die Tiers rechts):",
    manual_tiers_hint: "Visuelle manuelle Tierlist (S / A / B / C / D).",
    manual_back: "Zurück",
    manual_download_btn: "Manuelle Tierlist als Bild",
    manual_save_error: "Manuelle Tierlist konnte nicht gespeichert werden.",
    // Edit
    edit_title: "Spiel bearbeiten",
    edit_label_name: "Name",
    edit_label_image_url: "Bild-URL (optional)",
    edit_label_image_file: "Bild-Datei (optional)",
    edit_cancel: "Abbrechen",
    edit_save: "Speichern",
    status_edit_saved: "Spiel aktualisiert."
  }
};

const LANG_STORAGE_KEY = "tierlist_tool_lang";
const MODE_STORAGE_KEY = "tierlist_tool_mode";
const STORAGE_KEY = "tierlist_tool_state_v3";

let currentLang = "ru";
let rankingMode = "exact";

function tr(key, params) {
  const dict = I18N[currentLang] || I18N.ru;
  let s = dict[key] || (I18N.en && I18N.en[key]) || key;
  if (params) {
    for (const p in params) {
      s = s.replace(new RegExp("\\{" + p + "\\}", "g"), params[p]);
    }
  }
  return s;
}

function formatGameCount(count) {
  if (currentLang === "ru") {
    const mod10 = count % 10;
    const mod100 = count % 100;
    let word;
    if (mod10 === 1 && mod100 !== 11) word = "игра";
    else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) word = "игры";
    else word = "игр";
    return count + " " + word;
  } else if (currentLang === "de") {
    return count + " " + (count === 1 ? "Spiel" : "Spiele");
  } else {
    return count + " " + (count === 1 ? "game" : "games");
  }
}

function formatComparisonCount(n) {
  if (currentLang === "ru") {
    const mod10 = n % 10;
    const mod100 = n % 100;
    let word;
    if (mod10 === 1 && mod100 !== 11) word = "сравнение";
    else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) word = "сравнения";
    else word = "сравнений";
    return n + " " + word;
  } else if (currentLang === "de") {
    return n + " " + (n === 1 ? "Vergleich" : "Vergleiche");
  } else {
    return n + " " + (n === 1 ? "comparison" : "comparisons");
  }
}

function factorialLog2(n) {
  let sum = 0;
  for (let k = 2; k <= n; k++) sum += Math.log2(k);
  return sum;
}

function exactComparisonsEstimate(n) {
  let res = 0;
  for (let len = 1; len <= n - 1; len++) {
    res += Math.ceil(Math.log2(len + 1));
  }
  return res;
}

const MANUAL_TITLE_MAX = 26;
function shortenManualTitle(text, maxLen = MANUAL_TITLE_MAX) {
  if (!text) return "";
  text = String(text);
  return text.length > maxLen ? text.slice(0, maxLen - 1) + "…" : text;
}

/* ---------- State ---------- */

const games = [];
let nextId = 1;

let sortedIndices = [];
let compareOrder = [];
let comparePos = 0;
let currentNewIndex = null;
let low = 0;
let high = 0;
let mid = 0;
let compareActive = false;
let comparisonsDone = 0;

// Manueller Tierlist-Zustand
const manualTiers = { S: [], A: [], B: [], C: [], D: [] };
let manualPool = [];
let manualDragSourceIndex = null;

// editierbare Namen der Ränge
let manualTierNames = { S: "S", A: "A", B: "B", C: "C", D: "D" };

const TIER_CONFIG = [
  { key: "S", defaultName: "S", color: "#f97316" },
  { key: "A", defaultName: "A", color: "#facc15" },
  { key: "B", defaultName: "B", color: "#22c55e" },
  { key: "C", defaultName: "C", color: "#38bdf8" },
  { key: "D", defaultName: "D", color: "#a855f7" }
];

/* ---------- Helpers ---------- */

function cleanTitle(rawTitle, url) {
  let t = (rawTitle || "").trim();
  if (!t) return t;
  if (url && url.includes("store.steampowered.com")) {
    t = t.replace(/ on Steam$/i, "");
    t = t.replace(/^Save \d+% on /i, "");
    t = t.replace(/^Buy /i, "");
  }
  return t.trim();
}

function showStatus(msg, type) {
  const el = document.getElementById("status");
  el.textContent = msg;
  el.className = "status " + type;
  el.classList.remove("hidden");
}

function hideStatus() {
  document.getElementById("status").classList.add("hidden");
}

function updateGameCount() {
  const count = games.length;
  document.getElementById("gameCountHint").textContent = formatGameCount(count);
  const startAuto = document.getElementById("startTierButton");
  const startManual = document.getElementById("startManualTierButton");
  const disabled = count < 5;
  startAuto.disabled = disabled;
  startManual.disabled = disabled;
  updateClickStatsDisplay();
}

function resetTierResults() {
  sortedIndices = [];
  compareOrder = [];
  comparePos = 0;
  currentNewIndex = null;
  low = high = mid = 0;
  compareActive = false;
  comparisonsDone = 0;

  document.getElementById("finishedPanel").classList.add("hidden");
  document.getElementById("tierTableSection").classList.add("hidden");
  document.getElementById("rankList").innerHTML = "";
  document.getElementById("tierTableWrapper").innerHTML = "";
  document.getElementById("progressInfo").textContent = tr("progress_not_started");
}

function clearManualState() {
  manualTiers.S = [];
  manualTiers.A = [];
  manualTiers.B = [];
  manualTiers.C = [];
  manualTiers.D = [];
  manualPool = [];
}

function filterIndicesForGames(arr) {
  if (!Array.isArray(arr)) return [];
  return arr
    .map(i => Number(i))
    .filter(i => Number.isInteger(i) && i >= 0 && i < games.length);
}

function syncManualPoolWithGames() {
  const used = new Set();
  for (const key of ["S", "A", "B", "C", "D"]) {
    manualTiers[key] = filterIndicesForGames(manualTiers[key]);
    manualTiers[key].forEach(i => used.add(i));
  }
  manualPool = filterIndicesForGames(manualPool).filter(i => !used.has(i));
  for (let i = 0; i < games.length; i++) {
    if (!used.has(i) && !manualPool.includes(i)) {
      manualPool.push(i);
    }
  }
}

/* ---------- Language & Mode ---------- */

function updateClickStatsDisplay() {
  const n = games.length;
  const el = document.getElementById("clickStats");
  if (!el) return;

  if (n <= 1) {
    el.textContent = "";
    return;
  }

  const min = Math.ceil(factorialLog2(n));
  const exactEst = exactComparisonsEstimate(n);
  const fastEst = Math.max(1, Math.round(exactEst * 0.5));

  el.textContent = tr("click_stats", {
    min,
    exact: exactEst,
    fast: fastEst
  });
}

function applyLanguageStaticTexts() {
  const s = I18N[currentLang] || I18N.ru;

  document.title = s.page_title;
  document.getElementById("txt_title").textContent = s.main_title;
  document.getElementById("lbl_lang").textContent = s.lang_label;
  document.getElementById("txt_subtitle").innerHTML = s.subtitle_html;
  document.getElementById("lbl_url").textContent = s.label_url;
  document.getElementById("urlInput").placeholder = s.placeholder_url;
  document.getElementById("lbl_multi").textContent = s.label_multi;
  document.getElementById("multiInput").placeholder = s.placeholder_multi;
  document.getElementById("addButton").textContent = s.btn_add_game;
  document.getElementById("clearButton").textContent = s.btn_clear_list;
  document.getElementById("addManyButton").textContent = s.btn_add_many;
  document.getElementById("hint_multi").textContent = s.hint_multi;
  document.getElementById("title_collected").textContent = s.section_collected;
  document.getElementById("hint_min_games").textContent = s.hint_min_games;
  document.getElementById("title_result").textContent = s.result_title;
  document.getElementById("hint_sorted_list").textContent = s.finished_hint;
  document.getElementById("hint_visual").textContent = s.tier_visual_hint;
  document.getElementById("downloadTierImageButton").textContent = s.btn_download_image;
  document.getElementById("txt_overlay_title").textContent = s.overlay_title;
  document.getElementById("txt_overlay_subtitle").textContent = s.overlay_subtitle;
  document.getElementById("lbl_left_choice").textContent = s.overlay_left_label;
  document.getElementById("lbl_right_choice").textContent = s.overlay_right_label;
  document.getElementById("fsCancel").textContent = s.overlay_cancel;

  document.getElementById("lbl_manual_section").textContent = s.manual_section_title;
  document.getElementById("lbl_manual_name").textContent = s.manual_label_name;
  document.getElementById("lbl_manual_image_file").textContent = s.manual_label_image_file;
  document.getElementById("lbl_manual_image_url").textContent = s.manual_label_image_url;
  document.getElementById("manual_hint").textContent = s.manual_hint;
  document.getElementById("addManualButton").textContent = s.btn_add_manual;

  document.getElementById("modeLabel").textContent = s.mode_label;

  const modeSelect = document.getElementById("modeSelect");
  const optExact = modeSelect.querySelector('option[value="exact"]');
  const optFast = modeSelect.querySelector('option[value="fast"]');
  if (optExact) optExact.textContent = s.mode_exact;
  if (optFast) optFast.textContent = s.mode_fast;

  document.getElementById("startTierButton").textContent = s.btn_start_auto;
  document.getElementById("startManualTierButton").textContent = s.btn_start_manual;

  document.getElementById("share_title").textContent = s.share_title;
  document.getElementById("share_hint").textContent = s.share_hint;
  document.getElementById("btnExportGames").textContent = s.btn_export_games;
  document.getElementById("btnImportGames").textContent = s.btn_import_games;

  // Manueller Tierlist
  document.getElementById("manual_title").textContent = s.manual_title;
  document.getElementById("manual_subtitle").textContent = s.manual_subtitle;
  document.getElementById("manual_pool_title").textContent = s.manual_pool_title;
  document.getElementById("manual_pool_subtitle").textContent = s.manual_pool_title;
  document.getElementById("manual_tiers_hint").textContent = s.manual_tiers_hint;
  document.getElementById("manualBackButton").textContent = s.manual_back;
  document.getElementById("downloadManualTierImageButton").textContent = s.manual_download_btn;

  // Edit-Dialog
  document.getElementById("editDialogTitle").textContent = s.edit_title;
  document.getElementById("editLabelName").textContent = s.edit_label_name;
  document.getElementById("editLabelImageUrl").textContent = s.edit_label_image_url;
  document.getElementById("editLabelImageFile").textContent = s.edit_label_image_file;
  document.getElementById("editCancelButton").textContent = s.edit_cancel;
  document.getElementById("editSaveButton").textContent = s.edit_save;

  updateClickStatsDisplay();
}

function refreshProgressInfoForCurrentState() {
  const progressInfo = document.getElementById("progressInfo");
  if (sortedIndices.length > 0 && !compareActive) {
    progressInfo.textContent = tr("progress_finished", {
      count: formatComparisonCount(comparisonsDone || 0)
    });
  } else if (compareActive) {
    progressInfo.textContent = tr("progress_running", {
      count: formatComparisonCount(comparisonsDone || 0)
    });
  } else if (games.length < 5) {
    progressInfo.textContent = tr("progress_need_n");
  } else {
    progressInfo.textContent = tr("progress_not_started");
  }
}

function initLanguage() {
  const select = document.getElementById("langSelect");
  let stored = "ru";
  try {
    const tmp = localStorage.getItem(LANG_STORAGE_KEY);
    if (tmp && ["ru", "en", "de"].includes(tmp)) stored = tmp;
  } catch (e) {}
  currentLang = stored;
  select.value = stored;

  applyLanguageStaticTexts();
  select.addEventListener("change", () => {
    currentLang = select.value;
    try {
      localStorage.setItem(LANG_STORAGE_KEY, currentLang);
    } catch (e) {}
    applyLanguageStaticTexts();
    updateGameCount();
    refreshProgressInfoForCurrentState();
    document.getElementById("fsProgress").textContent =
      formatComparisonCount(comparisonsDone || 0);
  });
}

function initMode() {
  const sel = document.getElementById("modeSelect");
  let stored = "exact";
  try {
    const tmp = localStorage.getItem(MODE_STORAGE_KEY);
    if (tmp === "exact" || tmp === "fast") stored = tmp;
  } catch (e) {}
  rankingMode = stored;
  sel.value = stored;

  sel.addEventListener("change", () => {
    rankingMode = sel.value;
    try {
      localStorage.setItem(MODE_STORAGE_KEY, rankingMode);
    } catch (e) {}
    updateClickStatsDisplay();
  });
}

/* ---------- Game-Liste rendern ---------- */

function renderGameList() {
  const listEl = document.getElementById("gameList");
  listEl.innerHTML = "";

  games.forEach((g, index) => {
    const row = document.createElement("div");
    row.className = "game-item";

    const img = document.createElement("img");
    img.className = "game-thumb";
    img.crossOrigin = "anonymous";
    img.src = g.image || "";
    img.alt = g.title || "Image";

    const info = document.createElement("div");
    info.className = "game-info";

    const title = document.createElement("div");
    title.className = "game-title";
    title.textContent = g.title || "(no title)";

    const url = document.createElement("div");
    url.className = "game-url";
    url.textContent = g.url;

    info.appendChild(title);
    info.appendChild(url);

    const badge = document.createElement("div");
    badge.className = "rank-badge";
    badge.textContent = "#" + (index + 1);

    const editBtn = document.createElement("button");
    editBtn.type = "button";
    editBtn.className = "btn-icon";
    editBtn.textContent = "✎";
    editBtn.title = "Edit";
    editBtn.addEventListener("click", () => openEditGame(index));

    const reloadBtn = document.createElement("button");
    reloadBtn.type = "button";
    reloadBtn.className = "btn-icon";
    reloadBtn.textContent = "⟳";
    reloadBtn.title = "Reload";
    reloadBtn.addEventListener("click", () => reloadGame(index));

    const delBtn = document.createElement("button");
    delBtn.type = "button";
    delBtn.className = "btn-icon danger";
    delBtn.textContent = "×";
    delBtn.title = "Delete";
    delBtn.addEventListener("click", () => deleteGame(index));

    row.appendChild(img);
    row.appendChild(info);
    row.appendChild(badge);
    row.appendChild(editBtn);
    row.appendChild(reloadBtn);
    row.appendChild(delBtn);

    listEl.appendChild(row);
  });

  syncManualPoolWithGames();
  updateGameCount();
}

/* ---------- Spiele hinzufügen ---------- */

async function fetchAndAddGame(rawUrl) {
  let finalUrl = (rawUrl || "").trim();
  if (!finalUrl) {
    return { success: false, skipped: true, error: "empty" };
  }

  if (!/^https?:\/\//i.test(finalUrl)) {
    finalUrl = "https://" + finalUrl;
  }

  const apiUrl = "/api/og?url=" + encodeURIComponent(finalUrl);

  try {
    const response = await fetch(apiUrl);
    if (!response.ok) throw new Error("HTTP " + response.status);

    const data = await response.json();
    if (!data.success) throw new Error(data.error || "Unknown error");

    const rawTitle = data.title || "(no title)";
    const url = data.url || finalUrl;
    const title = cleanTitle(rawTitle, url);
    const image = data.image || "";

    games.push({ id: nextId++, title, image, url });
    resetTierResults();
    renderGameList();
    saveState();

    return { success: true, title };
  } catch (err) {
    console.error(err);
    return { success: false, skipped: false, error: err.message };
  }
}

async function addGameFromUrl() {
  const inputEl = document.getElementById("urlInput");
  const rawUrl = inputEl.value.trim();
  const addBtn = document.getElementById("addButton");
  const addManyBtn = document.getElementById("addManyButton");

  if (!rawUrl) {
    showStatus(tr("status_enter_url"), "error");
    return;
  }

  hideStatus();
  showStatus(tr("status_loading_meta"), "info");
  addBtn.disabled = true;
  if (addManyBtn) addManyBtn.disabled = true;

  const result = await fetchAndAddGame(rawUrl);

  if (result.success) {
    showStatus(tr("status_game_added", { title: result.title }), "success");
    inputEl.value = "";
  } else if (!result.skipped) {
    showStatus(tr("status_load_error", { error: result.error }), "error");
  }

  addBtn.disabled = false;
  if (addManyBtn) addManyBtn.disabled = false;
}

async function addGamesFromMultiInput() {
  const multiEl = document.getElementById("multiInput");
  const text = multiEl.value;
  const addBtn = document.getElementById("addButton");
  const addManyBtn = document.getElementById("addManyButton");

  const lines = text
    .split(/\r?\n/)
    .map(l => l.trim())
    .filter(l => l.length > 0);

  if (!lines.length) {
    showStatus(tr("status_no_links"), "error");
    return;
  }

  hideStatus();
  let successCount = 0;
  let failCount = 0;

  addBtn.disabled = true;
  addManyBtn.disabled = true;

  for (let i = 0; i < lines.length; i++) {
    showStatus(
      tr("status_loading_multi_progress", {
        current: i + 1,
        total: lines.length
      }),
      "info"
    );
    const res = await fetchAndAddGame(lines[i]);
    if (res.success) {
      successCount++;
    } else if (!res.skipped) {
      failCount++;
    }
  }

  if (successCount > 0 && failCount === 0) {
    showStatus(
      tr("status_multi_success", { count: successCount }),
      "success"
    );
  } else if (successCount > 0) {
    showStatus(
      tr("status_multi_partial", {
        success: successCount,
        fail: failCount
      }),
      "success"
    );
  } else {
    showStatus(tr("status_multi_fail"), "error");
  }

  addBtn.disabled = false;
  addManyBtn.disabled = false;
  saveState();
}

function addManualGame() {
  const titleInput = document.getElementById("manualTitle");
  const urlInput = document.getElementById("manualImageUrl");
  const fileInput = document.getElementById("manualImage");

  const rawTitle = (titleInput.value || "").trim();
  const imgUrl = (urlInput.value || "").trim();
  const file = fileInput.files[0];

  const addBtn = document.getElementById("addButton");
  const addManyBtn = document.getElementById("addManyButton");
  const addManualBtn = document.getElementById("addManualButton");

  if (!rawTitle) {
    showStatus(tr("status_manual_need_title"), "error");
    return;
  }
  if (!imgUrl && !file) {
    showStatus(tr("status_manual_need_image_or_url"), "info");
    // trotzdem erlauben, aber ohne Bild
  }

  hideStatus();
  addBtn.disabled = true;
  if (addManyBtn) addManyBtn.disabled = true;
  addManualBtn.disabled = true;

  const finishAdd = (imageDataUrl) => {
    games.push({
      id: nextId++,
      title: rawTitle,
      image: imageDataUrl || imgUrl || "",
      url: ""
    });

    resetTierResults();
    renderGameList();
    showStatus(tr("status_manual_added", { title: rawTitle }), "success");
    titleInput.value = "";
    urlInput.value = "";
    fileInput.value = "";
    saveState();

    addBtn.disabled = false;
    if (addManyBtn) addManyBtn.disabled = false;
    addManualBtn.disabled = false;
  };

  if (file) {
    showStatus(tr("status_manual_loading"), "info");
    const reader = new FileReader();
    reader.onload = (e) => {
      finishAdd(e.target.result);
    };
    reader.onerror = (e) => {
      console.error("FileReader error", e);
      showStatus(tr("status_manual_file_error"), "error");
      addBtn.disabled = false;
      if (addManyBtn) addManyBtn.disabled = false;
      addManualBtn.disabled = false;
    };
    reader.readAsDataURL(file);
  } else {
    finishAdd("");
  }
}

/* ---------- Löschen & Reload ---------- */

function deleteGame(index) {
  if (index < 0 || index >= games.length) return;
  games.splice(index, 1);

  // Auto-Ranking ungültig → zurücksetzen
  resetTierResults();

  // Manueller Tierlist anpassen
  for (const key of ["S", "A", "B", "C", "D"]) {
    manualTiers[key] = manualTiers[key]
      .filter(i => i !== index)
      .map(i => (i > index ? i - 1 : i));
  }
  manualPool = manualPool
    .filter(i => i !== index)
    .map(i => (i > index ? i - 1 : i));

  renderGameList();
  updateGameCount();
  saveState();
}

async function reloadGame(index) {
  const g = games[index];
  if (!g || !g.url) return;

  const addBtn = document.getElementById("addButton");
  const addManyBtn = document.getElementById("addManyButton");

  hideStatus();
  showStatus(tr("status_update_game", { title: g.title || g.url }), "info");

  addBtn.disabled = true;
  if (addManyBtn) addManyBtn.disabled = true;

  let finalUrl = g.url || "";
  if (!/^https?:\/\//i.test(finalUrl)) finalUrl = "https://" + finalUrl;

  const apiUrl = "/api/og?url=" + encodeURIComponent(finalUrl);

  try {
    const response = await fetch(apiUrl);
    if (!response.ok) throw new Error("HTTP " + response.status);

    const data = await response.json();
    if (!data.success) throw new Error(data.error || "Unknown error");

    const rawTitle = data.title || "(no title)";
    const url = data.url || finalUrl;
    const title = cleanTitle(rawTitle, url);
    const image = data.image || "";

    games[index].title = title;
    games[index].image = image;
    games[index].url   = url;

    resetTierResults();
    renderGameList();
    showStatus(tr("status_update_game_ok", { title }), "success");
    saveState();
  } catch (err) {
    console.error(err);
    showStatus(
      tr("status_update_game_fail", { error: err.message }),
      "error"
    );
  } finally {
    addBtn.disabled = false;
    if (addManyBtn) addManyBtn.disabled = false;
  }
}

/* ---------- Bearbeiten-Dialog ---------- */

let editIndex = null;

function openEditGame(index) {
  const g = games[index];
  if (!g) return;

  editIndex = index;

  const nameInput = document.getElementById("editGameName");
  const urlInput  = document.getElementById("editImageUrl");
  const fileInput = document.getElementById("editImageFile");
  const preview   = document.getElementById("editPreview");

  nameInput.value = g.title || "";
  if (g.image && g.image.startsWith("data:")) {
    urlInput.value = "";
  } else {
    urlInput.value = g.image || "";
  }
  fileInput.value = "";
  preview.src = g.image || "";
  preview.alt = g.title || "";

  document.getElementById("editOverlay").classList.remove("hidden");
}

function closeEditDialog() {
  editIndex = null;
  document.getElementById("editOverlay").classList.add("hidden");
}

function saveEditGame() {
  if (editIndex === null) return;
  const g = games[editIndex];
  if (!g) {
    closeEditDialog();
    return;
  }

  const nameInput = document.getElementById("editGameName");
  const urlInput  = document.getElementById("editImageUrl");
  const fileInput = document.getElementById("editImageFile");

  const newTitle = nameInput.value.trim();
  const imgUrl   = urlInput.value.trim();
  const file     = fileInput.files[0];

  if (!newTitle) {
    showStatus(tr("status_manual_need_title"), "error");
    return;
  }

  g.title = newTitle;

  const finish = () => {
    resetTierResults();
    renderGameList();
    saveState();
    showStatus(tr("status_edit_saved"), "success");
    closeEditDialog();
  };

  if (file) {
    showStatus(tr("status_manual_loading"), "info");
    const reader = new FileReader();
    reader.onload = (e) => {
      g.image = e.target.result;
      finish();
    };
    reader.onerror = (e) => {
      console.error(e);
      showStatus(tr("status_manual_file_error"), "error");
    };
    reader.readAsDataURL(file);
  } else {
    if (imgUrl) {
      g.image = imgUrl;
    }
    finish();
  }
}

/* ---------- Auto-Tierlist (Vergleich) ---------- */

const mainContainer = document.getElementById("mainContainer");
const overlay = document.getElementById("compareOverlay");
const fsStatus = document.getElementById("fsStatus");
const fsProgress = document.getElementById("fsProgress");
const fsImgLeft = document.getElementById("fsImgLeft");
const fsImgRight = document.getElementById("fsImgRight");
const fsNameLeft = document.getElementById("fsNameLeft");
const fsNameRight = document.getElementById("fsNameRight");

function startTierlist() {
  if (games.length < 5) {
    showStatus(tr("progress_need_n"), "error");
    return;
  }

  hideStatus();

  // Neue Sortierung immer komplett
  sortedIndices = [0];
  compareOrder = [];
  for (let i = 1; i < games.length; i++) compareOrder.push(i);
  comparePos = 0;
  currentNewIndex = null;
  low = high = mid = 0;
  comparisonsDone = 0;
  compareActive = true;

  document.getElementById("finishedPanel").classList.add("hidden");
  document.getElementById("tierTableSection").classList.add("hidden");
  document.getElementById("progressInfo").textContent = tr("progress_running", {
    count: formatComparisonCount(comparisonsDone || 0)
  });

  mainContainer.classList.add("hidden");
  overlay.classList.remove("hidden");
  fsStatus.textContent = tr("overlay_status_start");
  fsProgress.textContent = formatComparisonCount(comparisonsDone || 0);

  moveToNextNewGame();
}

function moveToNextNewGame() {
  if (!compareOrder.length) {
    currentNewIndex = null;
    finishTierlist();
    return;
  }
  currentNewIndex = compareOrder.shift();
  low = 0;
  high = sortedIndices.length;
  showNextComparisonStep();
}

function showNextComparisonStep() {
  if (!compareActive || currentNewIndex === null) return;

  if (low >= high) {
    sortedIndices.splice(low, 0, currentNewIndex);
    saveState();
    moveToNextNewGame();
    return;
  }

  mid = Math.floor((low + high) / 2);
  const existingIndex = sortedIndices[mid];

  const newGame = games[currentNewIndex];
  const existingGame = games[existingIndex];

  fsImgLeft.crossOrigin = "anonymous";
  fsImgRight.crossOrigin = "anonymous";

  fsImgLeft.src = newGame.image || "";
  fsImgLeft.alt = newGame.title || "";
  fsNameLeft.textContent = newGame.title || "(no title)";

  fsImgRight.src = existingGame.image || "";
  fsImgRight.alt = existingGame.title || "";
  fsNameRight.textContent = existingGame.title || "(no title)";

  fsStatus.textContent = tr("overlay_status_start");
  fsProgress.textContent = formatComparisonCount(comparisonsDone || 0);
}

function chooseLeft() {
  if (!compareActive || currentNewIndex === null) return;
  comparisonsDone++;
  high = mid;
  fsProgress.textContent = formatComparisonCount(comparisonsDone);
  saveState();
  showNextComparisonStep();
}

function chooseRight() {
  if (!compareActive || currentNewIndex === null) return;
  comparisonsDone++;
  low = mid + 1;
  fsProgress.textContent = formatComparisonCount(comparisonsDone);
  saveState();
  showNextComparisonStep();
}

function finishTierlist() {
  compareActive = false;
  overlay.classList.add("hidden");
  mainContainer.classList.remove("hidden");

  document.getElementById("progressInfo").textContent = tr("progress_finished", {
    count: formatComparisonCount(comparisonsDone || 0)
  });

  document.getElementById("finishedPanel").classList.remove("hidden");
  document.getElementById("tierTableSection").classList.remove("hidden");

  renderRankList();
  renderTierTable();
  saveState();
}

function cancelTierlist() {
  compareActive = false;
  overlay.classList.add("hidden");
  mainContainer.classList.remove("hidden");
  document.getElementById("progressInfo").textContent = tr("progress_cancelled");
  saveState();
}

function renderRankList() {
  const list = document.getElementById("rankList");
  list.innerHTML = "";

  const total = sortedIndices.length;

  sortedIndices.forEach((gameIndex, i) => {
    const g = games[gameIndex];
    const row = document.createElement("div");
    row.className = "rank-row";

    const n = document.createElement("div");
    n.className = "rank-number";
    n.textContent = (i + 1) + ".";

    const t = document.createElement("div");
    t.className = "rank-title";
    t.textContent = g.title;

    const badge = document.createElement("div");
    badge.className = "rank-badge";
    badge.textContent = getTierLabelByIndex(i, total) + "-tier";

    row.appendChild(n);
    row.appendChild(t);
    row.appendChild(badge);
    list.appendChild(row);
  });
}

function getTierLabelByIndex(index, total) {
  if (total <= 1) return "S";
  const ratio = index / (total - 1);
  if (ratio <= 0.2) return "S";
  if (ratio <= 0.4) return "A";
  if (ratio <= 0.6) return "B";
  if (ratio <= 0.8) return "C";
  return "D";
}

function renderTierTable() {
  const section = document.getElementById("tierTableSection");
  const wrapper = document.getElementById("tierTableWrapper");
  wrapper.innerHTML = "";

  const total = sortedIndices.length;
  if (!total) {
    section.classList.add("hidden");
    return;
  }

  const tiers = { S: [], A: [], B: [], C: [], D: [] };

  sortedIndices.forEach((gameIndex, i) => {
    const g = games[gameIndex];
    const tierLabel = getTierLabelByIndex(i, total);
    tiers[tierLabel].push(g);
  });

  TIER_CONFIG.forEach(cfg => {
    const row = document.createElement("div");
    row.className = "tier-row";

    const labelCell = document.createElement("div");
    labelCell.className = "tier-label-cell";
    labelCell.style.background = cfg.color;
    labelCell.textContent = cfg.key;

    const itemsCell = document.createElement("div");
    itemsCell.className = "tier-items-cell";

    const list = tiers[cfg.key] || [];
    if (!list.length) {
      const emptyText = document.createElement("span");
      emptyText.className = "small-hint";
      emptyText.textContent = "—";
      itemsCell.appendChild(emptyText);
    } else {
      list.forEach(g => {
        const img = document.createElement("img");
        img.className = "tier-item-img";
        img.crossOrigin = "anonymous";
        img.src = g.image || "";
        img.alt = g.title;
        itemsCell.appendChild(img);
      });
    }

    row.appendChild(labelCell);
    row.appendChild(itemsCell);
    wrapper.appendChild(row);
  });
}

async function downloadTierImage() {
  const wrapper = document.getElementById("tierTableWrapper");
  if (!wrapper || !wrapper.children.length) {
    alert(tr("tierlist_not_created"));
    return;
  }

  try {
    const canvas = await html2canvas(wrapper, {
      backgroundColor: "#020617",
      scale: 2,
      useCORS: true
    });

    const link = document.createElement("a");
    link.download = "tierlist_auto.png";
    link.href = canvas.toDataURL("image/png");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  } catch (e) {
    console.error(e);
    alert(tr("tierlist_save_error"));
  }
}

/* ---------- Spiele-Export ohne Ranking + GitHub Gist ---------- */

function exportGamesOnly() {
  if (!games.length) {
    showStatus(tr("share_no_games"), "error");
    return;
  }

  const data = {
    games: games.map(g => ({
      id: g.id,
      title: g.title,
      image: g.image,
      url: g.url
    }))
  };

  const json = JSON.stringify(data);
  const base64 = btoa(unescape(encodeURIComponent(json)));

  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(base64).then(() => {
      showStatus(tr("share_export_copied"), "success");
    }).catch(() => {
      showStatus(tr("share_export_copy_manual"), "info");
      alert(base64);
    });
  } else {
    showStatus(tr("share_export_copy_manual"), "info");
    alert(base64);
  }
}

function isGistUrl(str) {
  return /https?:\/\/gist\.github\.com\//i.test(str);
}

function gistToRaw(url) {
  const m = url.match(/https?:\/\/gist\.github\.com\/([^\/]+)\/([a-f0-9]+)/i);
  if (!m) return null;
  return "https://gist.githubusercontent.com/" + m[1] + "/" + m[2] + "/raw";
}

async function importGamesOnly() {
  const input = prompt(tr("share_import_prompt"));
  if (!input) return;
  const trimmed = input.trim();

  let base64Text = null;

  try {
    if (/^https?:\/\//i.test(trimmed)) {
      // URL (evtl. Gist)
      let url = trimmed;

      if (isGistUrl(url)) {
        const rawUrl = gistToRaw(url);
        if (!rawUrl) throw new Error("Invalid Gist URL.");
        url = rawUrl;
      }
      const resp = await fetch(url);
      if (!resp.ok) throw new Error("HTTP " + resp.status);
      base64Text = (await resp.text()).trim();
    } else {
      base64Text = trimmed;
    }

    const json = decodeURIComponent(escape(atob(base64Text)));
    const data = JSON.parse(json);

    if (!data || !Array.isArray(data.games)) {
      throw new Error("Invalid format (games missing).");
    }

    games.length = 0;
    data.games.forEach((g, i) => {
      games.push({
        id: typeof g.id === "number" ? g.id : i + 1,
        title: g.title || "",
        image: g.image || "",
        url: g.url || ""
      });
    });

    let maxId = 0;
    games.forEach(g => {
      if (typeof g.id === "number" && g.id > maxId) maxId = g.id;
    });
    nextId = maxId + 1;

    resetTierResults();
    clearManualState();
    syncManualPoolWithGames();
    renderGameList();
    saveState();

    showStatus(tr("share_import_success"), "success");
  } catch (e) {
    console.error(e);
    showStatus(tr("share_import_fail", { error: e.message }), "error");
  }
}

/* ---------- Manueller Tierlist (Drag & Drop) ---------- */

const manualOverlay = document.getElementById("manualOverlay");
const manualPoolListEl = document.getElementById("manualPoolList");
const manualTierWrapperEl = document.getElementById("manualTierWrapper");

function removeGameFromAllManual(idx) {
  manualPool = manualPool.filter(i => i !== idx);
  for (const key of ["S", "A", "B", "C", "D"]) {
    manualTiers[key] = manualTiers[key].filter(i => i !== idx);
  }
}

function moveGameToPool(idx) {
  removeGameFromAllManual(idx);
  if (!manualPool.includes(idx)) manualPool.push(idx);
}

function moveGameToTier(idx, tierKey) {
  removeGameFromAllManual(idx);
  if (!manualTiers[tierKey].includes(idx)) manualTiers[tierKey].push(idx);
}

function manualCreateCard(gameIndex, inTier) {
  const g = games[gameIndex];
  if (!g) return null;

  const card = document.createElement("div");
  card.draggable = true;
  card.dataset.index = String(gameIndex);
  card.className = inTier ? "manual-tier-card" : "manual-card";

  const img = document.createElement("img");
  img.src = g.image || "";
  img.alt = g.title || "";
  img.crossOrigin = "anonymous";
  img.className = inTier ? "manual-tier-card-thumb" : "manual-card-thumb";

  const title = document.createElement("div");
  title.className = inTier ? "manual-tier-card-name" : "manual-card-name";
  const fullTitle = g.title || "(no title)";
  title.textContent = shortenManualTitle(fullTitle);
  title.title = fullTitle;

  card.appendChild(img);
  card.appendChild(title);

  card.addEventListener("dragstart", manualDragStart);
  card.addEventListener("dragend", manualDragEnd);

  return card;
}

function manualDragStart(e) {
  manualDragSourceIndex = parseInt(this.dataset.index, 10);
  e.dataTransfer.effectAllowed = "move";
}

function manualDragEnd() {
  manualDragSourceIndex = null;
  document
    .querySelectorAll(".manual-tier-dropzone, #manualPoolList")
    .forEach(z => z.classList.remove("over"));
}

function manualDropzoneDragOver(e) {
  e.preventDefault();
  if (manualDragSourceIndex === null) return;
  this.classList.add("over");
  e.dataTransfer.dropEffect = "move";
}

function manualDropzoneDragLeave(e) {
  e.preventDefault();
  this.classList.remove("over");
}

function manualDropToTier(e) {
  e.preventDefault();
  this.classList.remove("over");
  if (manualDragSourceIndex === null) return;
  const tierKey = this.dataset.tier;
  moveGameToTier(manualDragSourceIndex, tierKey);
  renderManualView();
  saveState();
}

function manualPoolDragOver(e) {
  e.preventDefault();
  if (manualDragSourceIndex === null) return;
  manualPoolListEl.classList.add("over");
  e.dataTransfer.dropEffect = "move";
}

function manualPoolDragLeave(e) {
  e.preventDefault();
  manualPoolListEl.classList.remove("over");
}

function manualDropToPool(e) {
  e.preventDefault();
  manualPoolListEl.classList.remove("over");
  if (manualDragSourceIndex === null) return;
  moveGameToPool(manualDragSourceIndex);
  renderManualView();
  saveState();
}

function createManualTierRowsIfNeeded() {
  if (manualTierWrapperEl.children.length) return;
  manualTierWrapperEl.innerHTML = "";

  TIER_CONFIG.forEach(cfg => {
    const row = document.createElement("div");
    row.className = "manual-tier-row";

    const labelCell = document.createElement("div");
    labelCell.className = "manual-tier-label";
    labelCell.style.background = cfg.color;
    labelCell.dataset.tierkey = cfg.key;
    labelCell.contentEditable = "true";
    labelCell.spellcheck = false;
    labelCell.textContent = manualTierNames[cfg.key] || cfg.defaultName;

    labelCell.addEventListener("input", () => {
      const t = (labelCell.textContent || "").trim();
      manualTierNames[cfg.key] = t || cfg.defaultName;
      saveState();
    });

    const dropzone = document.createElement("div");
    dropzone.className = "manual-tier-dropzone";
    dropzone.dataset.tier = cfg.key;

    dropzone.addEventListener("dragover", manualDropzoneDragOver);
    dropzone.addEventListener("dragleave", manualDropzoneDragLeave);
    dropzone.addEventListener("drop", manualDropToTier);

    row.appendChild(labelCell);
    row.appendChild(dropzone);
    manualTierWrapperEl.appendChild(row);
  });

  manualPoolListEl.addEventListener("dragover", manualPoolDragOver);
  manualPoolListEl.addEventListener("dragleave", manualPoolDragLeave);
  manualPoolListEl.addEventListener("drop", manualDropToPool);
}

function renderManualView() {
  createManualTierRowsIfNeeded();

  // Pool
  manualPoolListEl.innerHTML = "";
  manualPool.forEach(idx => {
    if (idx < 0 || idx >= games.length) return;
    const card = manualCreateCard(idx, false);
    if (card) manualPoolListEl.appendChild(card);
  });

  // Tiers
  const dropzones = manualTierWrapperEl.querySelectorAll(".manual-tier-dropzone");
  dropzones.forEach(dz => {
    const tier = dz.dataset.tier;
    dz.innerHTML = "";
    (manualTiers[tier] || []).forEach(idx => {
      if (idx < 0 || idx >= games.length) return;
      const card = manualCreateCard(idx, true);
      if (card) dz.appendChild(card);
    });
  });
}

async function downloadManualTierImage() {
  const wrapper = document.getElementById("manualTierWrapper");
  if (!wrapper || !wrapper.children.length) {
    alert(tr("tierlist_not_created"));
    return;
  }

  try {
    const canvas = await html2canvas(wrapper, {
      backgroundColor: "#020617",
      scale: 2,
      useCORS: true
    });

    const link = document.createElement("a");
    link.download = "tierlist_manual.png";
    link.href = canvas.toDataURL("image/png");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  } catch (e) {
    console.error(e);
    alert(tr("manual_save_error"));
  }
}

function openManualTierlist() {
  if (games.length < 5) {
    showStatus(tr("progress_need_n"), "error");
    return;
  }

  hideStatus();
  syncManualPoolWithGames();
  renderManualView();

  mainContainer.classList.add("hidden");
  compareActive = false;
  overlay.classList.add("hidden");
  manualOverlay.classList.remove("hidden");
}

function closeManualOverlay() {
  manualOverlay.classList.add("hidden");
  mainContainer.classList.remove("hidden");
  saveState();
}

/* ---------- Speichern / Laden ---------- */

function saveState() {
  try {
    const finishedPanelHidden = document
      .getElementById("finishedPanel")
      .classList.contains("hidden");

    const state = {
      games: games,
      sortedIndices: sortedIndices,
      comparisonsDone: comparisonsDone,
      finished: !finishedPanelHidden,
      manual: {
        tiers: manualTiers,
        pool: manualPool,
        tierNames: manualTierNames
      }
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  } catch (e) {
    console.error("Fehler beim Speichern", e);
  }
}

function loadState() {
  let raw;
  try {
    raw = localStorage.getItem(STORAGE_KEY);
  } catch (e) {
    console.error("Fehler beim Lesen aus localStorage", e);
    return;
  }
  if (!raw) return;

  try {
    const state = JSON.parse(raw);
    if (!state || !Array.isArray(state.games)) return;

    games.length = 0;
    state.games.forEach((g, i) => {
      if (typeof g.id !== "number") g.id = i + 1;
      games.push({
        id: g.id,
        title: g.title || "",
        image: g.image || "",
        url: g.url || ""
      });
    });

    sortedIndices = Array.isArray(state.sortedIndices)
      ? state.sortedIndices.filter(i =>
          Number.isInteger(i) && i >= 0 && i < games.length
        )
      : [];
    comparisonsDone = typeof state.comparisonsDone === "number"
      ? state.comparisonsDone
      : 0;

    clearManualState();
    if (state.manual && state.manual.tiers) {
      manualTiers.S = filterIndicesForGames(state.manual.tiers.S);
      manualTiers.A = filterIndicesForGames(state.manual.tiers.A);
      manualTiers.B = filterIndicesForGames(state.manual.tiers.B);
      manualTiers.C = filterIndicesForGames(state.manual.tiers.C);
      manualTiers.D = filterIndicesForGames(state.manual.tiers.D);
    }
    if (state.manual && Array.isArray(state.manual.pool)) {
      manualPool = filterIndicesForGames(state.manual.pool);
    }
    if (state.manual && state.manual.tierNames) {
      const tNames = state.manual.tierNames;
      ["S", "A", "B", "C", "D"].forEach(key => {
        if (typeof tNames[key] === "string" && tNames[key].trim()) {
          manualTierNames[key] = tNames[key];
        }
      });
    }

    let maxId = 0;
    games.forEach(g => {
      if (typeof g.id === "number" && g.id > maxId) maxId = g.id;
    });
    nextId = maxId + 1;

    renderGameList();

    const finished = !!state.finished;
    const finishedPanel = document.getElementById("finishedPanel");
    const tierTableSection = document.getElementById("tierTableSection");
    const progressInfo = document.getElementById("progressInfo");

    if (finished && sortedIndices.length > 0) {
      finishedPanel.classList.remove("hidden");
      tierTableSection.classList.remove("hidden");
      renderRankList();
      renderTierTable();
      progressInfo.textContent = tr("progress_finished", {
        count: formatComparisonCount(comparisonsDone || 0)
      });
      mainContainer.classList.remove("hidden");
      overlay.classList.add("hidden");
    } else {
      finishedPanel.classList.add("hidden");
      tierTableSection.classList.add("hidden");
      progressInfo.textContent = games.length < 5
        ? tr("progress_need_n")
        : tr("progress_not_started");
      mainContainer.classList.remove("hidden");
      overlay.classList.add("hidden");
    }
  } catch (e) {
    console.error("Fehler beim Parsen des gespeicherten Zustands", e);
  }
}

/* ---------- Events ---------- */

document.getElementById("addButton").addEventListener("click", addGameFromUrl);
document.getElementById("addManyButton").addEventListener("click", addGamesFromMultiInput);
document.getElementById("addManualButton").addEventListener("click", addManualGame);
document.getElementById("clearButton").addEventListener("click", () => {
  games.length = 0;
  nextId = 1;
  resetTierResults();
  clearManualState();
  renderGameList();
  hideStatus();
  try { localStorage.removeItem(STORAGE_KEY); } catch (e) {}
});

document.getElementById("startTierButton").addEventListener("click", startTierlist);
document.getElementById("startManualTierButton").addEventListener("click", openManualTierlist);
document.getElementById("downloadTierImageButton").addEventListener("click", downloadTierImage);
document.getElementById("downloadManualTierImageButton").addEventListener("click", downloadManualTierImage);
document.getElementById("manualBackButton").addEventListener("click", closeManualOverlay);

document.getElementById("urlInput").addEventListener("keydown", e => {
  if (e.key === "Enter") addGameFromUrl();
});

document.getElementById("fsCardLeft").addEventListener("click", chooseLeft);
document.getElementById("fsCardRight").addEventListener("click", chooseRight);
document.getElementById("fsCancel").addEventListener("click", cancelTierlist);

document.getElementById("btnExportGames").addEventListener("click", exportGamesOnly);
document.getElementById("btnImportGames").addEventListener("click", importGamesOnly);

document.getElementById("toggleManualSection").addEventListener("click", () => {
  const body = document.getElementById("manualSectionBody");
  const btn = document.getElementById("toggleManualSection");
  body.classList.toggle("hidden");
  if (body.classList.contains("hidden")) {
    btn.textContent = "▼";
  } else {
    btn.textContent = "▲";
  }
});

document.getElementById("editSaveButton").addEventListener("click", saveEditGame);
document.getElementById("editCancelButton").addEventListener("click", closeEditDialog);
document.getElementById("editOverlay").addEventListener("click", (e) => {
  if (e.target.id === "editOverlay") {
    closeEditDialog();
  }
});

window.addEventListener("load", () => {
  initLanguage();
  initMode();
  loadState();
  refreshProgressInfoForCurrentState();
  updateGameCount();
});
</script>
</body>
</html>
